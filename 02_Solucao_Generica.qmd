---
title: "02: O problema do poeta - Solução genérica"
subtitle: "Modelagem e solução do problema do poeta utilizando a formulação genérica"
format:
  lumo-html: 
    # logo: "logo.png"                                     # Optional. Path to a logo displayed above the title
    github-repo: "https://github.com/maykongpedro/PO_O_Problema_Do_Poeta"        # Optional. Adds a github corner at the top right
    primary-color: "#69b3a2"
    self-contained: true
    is-particlejs-enabled: true                          # Optional: display interactive particles in the document header
    bg-image: ""                                         # Optional: link to an image for the header background
    code-fold: false     # <<<<<<<<<< SEMPRE MOSTRAR OS CÓDIGOS
    code-tools: true     # (opcional) botões p/ copiar
author: Maykon Pedro
date: last-modified
---

## Introdução

Esse segundo documento consolida a resolução do problema com formulação genérica, pensando em escabilidade dos dado e boas práticas de programação usando Pyomo.

## Descrição do problema

Um poeta possui **40 ha de Pinus e 50 ha de floresta nativa**. Nos últimos 10 anos, o manejo do Pinus gerou **R\$ 36.000** com **800 dias de trabalho**, e o manejo da floresta nativa gerou **R\$ 60.000** com **1.500 dias de trabalho**.

Ele quer **maximizar a receita anual**, mas pode dedicar no máximo **180 dias/ano** ao manejo. Determine **quantos hectares de cada floresta** ele deve manejar por ano para obter a maior receita possível, respeitando os limites de área disponíveis.

::: column-margin
Esse é um enunciado simplificado do problema. A versão original pode ser consultada nos documentos do projeto.
:::

## Resumo dos dados

**Florestas**:

$$
\begin{aligned}
&\text{Pinus} = 40_{ha} \\
&\text{Nativa} = 50_{ha}
\end{aligned}
$$

**Receita anual por floresta:**

$$
\begin{aligned}
\text{Receita do Pinus}& = \text{R\$ } 36.000  \div  10_\text{anos} \div 40_{ha} \\
\text{Receita do Pinus}& = \text{R\$} 90_{ha/ano}
\end{aligned}
$$

$$
\begin{aligned}
\text{Receita da Nativa}& = \text{R\$ } 60.000  \div  10_\text{anos} \div 50_{ha} \\
\text{Receita da Nativa}& = \text{R\$} 120_{ha/ano}
\end{aligned}
$$

**Restrições de tempo de manejo por floresta:**

$$
\begin{aligned}
\text{Manejo do Pinus}& = 800_{dias}  \div  40_{ha} \div 10_\text{anos} \\
\text{Manejo do Pinus}& = 2_{dias/ha/ano}
\end{aligned}
$$

$$
\begin{aligned}
\text{Manejo de Nativa}& = 1500_{dias}  \div  50_{ha} \div 10_\text{anos} \\
\text{Manejo de Nativa}& = 3_{dias/ha/ano}
\end{aligned}
$$

## Formulação

### Índices/Conjuntos

$$
I \colon \text{Conjunto de recursos disponiveis(tempo, equipamentos, etc.), nesse caso, o tempo dedicado ao manejo}, \{1, \dots, m\}
$$

$$
J \colon \text{Conjunto de tipos de florestas (nativa, plantada, etc.)}, \{1, \ldots, n\}
$$

### Parâmetros

$$
c_j \colon \text{receita por hectare do tipo de floresta } j \in J
$$

$$
a_{ij} \colon \text{quantidade do recurso } i  \text{(dias/ha) exigida para o manejo do tipo } j \in J 
$$

$$
A_j \colon \text{area maxima disponivel do tipo de floresta } j \in J
$$

$$
b_i \colon \text{quantidade total disponivel do recurso } i
$$

### Variáveis de decisão

Pensando que a maximização da receita do Poeta está diretamente ligada ao preço recebido por floresta e à quantidade de hectares manejados, o item que pode ser alterado pensando no cenário ótimo, é a área a ser manejada para cada floresta. Sendo assim, as variáveis de decisão serão:

-   $x_1 \colon \text{número de hectares de floresta de Pinus a serem manejados}$
-   $x_2 \colon \text{número de hectares de floresta nativas a serem manejadas}$

### Função objetivo

Tendo como guia a maximização da receita anual (aqui chamaremos de Z), teremos que usar as receitas anualizadas para cada tipo de floresta (calculadas no tópico Resumo dos dados"). Assim, têm-se:

$$
\max z = \sum_{j \in J} c_j x_j
$$

A receita de pinus (R\$90 ha/ano) multiplicado pela área a ser manejada de pinus ($x_1$ ) irá gerar a receita total desse gênero. Somado isso com a receita da nativa (R\$120 ha/ano) multiplicado pela respectiva área, nos retorna a receita total das florestas do Poeta.

### Restrições

Devemos começar com a limitação de área para floresta, não temos como manejar mais hectares do que o disponível:

$$
x_j \leq A_j, \quad \forall\ j \in J 
$$

Após, precisamos checar no enunciado que o Poeta expressou sua vontade de não trabalhar mais que 180 dias por ano. Como calculamos o tempo gasto para cada floresta no tópico de resumo de dados, podemos chegar na seguint expressão matemática para representar a relação entre tempo de manejo x tempo máximo do poeta:

$$
\sum_{j \in J} a_{ij} x_j \leq b_i, \quad \forall\, i \in I
$$

Sendo 2 dias/ha/ano para o pinus ($x_1$ ) e 3 dias/ha/ano para a nativa ($x_2$ ).

Para finalizar, devemos definir uma restrição que impeça o modelo de manejar áreas negativas: $$
x_j \geq 0, \quad \forall\ j \in J 
$$

## Resolução do problema

### 0. Dados de entrada

```{python}

# vetor de receita por tipo de floresta
receita = [90, 120] 

# matriz de quantidade recursos exigida para cada manejo
tempo_por_manejo = [
  [2, 3]
]

# vetor de área máxima
area_max = [40, 50]

# vetor de recurso máximo
tempo_maximo = [180]

# quantidade de recursos
n_total_recursos = len(tempo_por_manejo)

# quantidade de florestas a serem manejadas
n_tipos_florestas = len(receita)
```

### 1. Importar bibliotecas

```{python}
import pyomo.environ as pyo
```

### 2. Importar e definir solver

```{python}
# o executável foi instalado via terminal e o python consegue encontrá-lo nativaemente
# solver = pyo.SolverFactory("glpk")

# o executável foi baixado no computador
caminho_do_executavel = "C:/Users/klmp00145394/Documents/glpk-4.65/w64/glpsol.exe"
solver = pyo.SolverFactory(_name="glpk", executable=caminho_do_executavel)
```

### 3. Declarar modelo

```{python}
modelo = pyo.ConcreteModel()
```

### 4. Declarar índices, parâmetros e variáveis de decisão

### 4.1 Índices

```{python}
modelo.I_recursos = range(n_total_recursos)
modelo.J_tipos_de_floresta = range(n_tipos_florestas)

```

### 4.2 Parâmetros

```{python}
# %% Receita por tipo de floresta ==================================

# criar dicionário
dict_receita = {j: receita[j] for j in modelo.J_tipos_de_floresta}

# declara o parâmetro no modelo
modelo.c_receita = pyo.Param(modelo.J_tipos_de_floresta, initialize=dict_receita)

# %% Quantidade do recurso i exigida para o manejo do tipo de floresta j =============

# criar o dicionário
dict_recurso_x_tipo_floresta = {
    (i, j): tempo_por_manejo[i][j]
    for i in modelo.I_recursos
    for j in modelo.J_tipos_de_floresta
}

# declarar o parâmetro no modelo
modelo.a_recursos_x_floresta = pyo.Param(
    modelo.I_recursos,
    modelo.J_tipos_de_floresta,
    initialize=dict_recurso_x_tipo_floresta,
)


# %% Área máxima disponível por tipo de floresta j ==================

# criar o dicionário
dict_area_maxima = {j: area_max[j] for j in modelo.J_tipos_de_floresta}

# declarar o parâmetro no modelo
modelo.area_maxima = pyo.Param(modelo.J_tipos_de_floresta, initialize=dict_area_maxima)

# %% Quantidade total do recurso i ==================================

# criar o dicionário
dict_limite_recurso = {b: tempo_maximo[b] for b in modelo.I_recursos}

# declarar o par6ametro no modelo
modelo.lim_recurso = pyo.Param(modelo.I_recursos, initialize=dict_limite_recurso)
```

### 4.3 Variáveis de decisão

```{python}
# as variáveis estão associadas ao conjunto J (tipos de florestas) e não podem ser negativas
modelo.x_variaveis = pyo.Var(modelo.J_tipos_de_floresta, within=pyo.NonNegativeReals)
```

### 5. Declarar função objetivo

```{python}

# criar função de apoio para calcular a receita
def regra_funcao_z(mod):
  # 1. calcula a receita total: receita do tipo de floresta manejado (R$/ha) * x hectares
  receita_total = sum(
    mod.c_receita[j] * mod.x_variaveis[j]
    for j in mod.J_tipos_de_floresta
  )
  # 2. retorna o resultaado
  return receita_total

# declarar função objetivo
modelo.z = pyo.Objective(
  rule = regra_funcao_z,
  sense = pyo.maximize
)
```

### 6. Declarar restrições

```{python}

# criar função para limitar a quantidade de área por tipo de floresta para cada variável
def regra_area_maxima(mod, j):
    return mod.x_variaveis[j] <= mod.area_maxima[j]


# declarar restrição
modelo.restricao_area_maxima = pyo.Constraint(
    modelo.J_tipos_de_floresta,  # sempre relacionar a restrição com os conjuntos
    rule=regra_area_maxima,
)


# criar função para checar o limite de recurso usado (tempo)
def regra_tempo_disponivel(mod, recurso_i):
    horas_totais = sum(
        mod.a_recursos_x_floresta[recurso_i, j] * mod.x_variaveis[j]
        for j in mod.J_tipos_de_floresta
    )

    return horas_totais <= mod.lim_recurso[recurso_i]


# declarar restrição
modelo.restricao_limite_recurso = pyo.Constraint(
    modelo.I_recursos,  # sempre relacionar a restrição com os conjuntos
    rule=regra_tempo_disponivel,
)

```

### 7. Resolver modelo

```{python}
# dando uma olhada na construção do modelo
modelo.pprint()
```

```{python}
# usando o solver para resolver o modelo
resultado = solver.solve(modelo)
```

### 8. Exportar resultados

```{python}
# resultados brutos do modelo
resultado.write
```

```{python}
# resultados organizados
# Função objetivo
print(f"Receita máxima (z) = R${pyo.value(modelo.z):.2f}")

# tipos de floresta
nome_tipos = {0: "Pinus", 1: "Nativa"}

for j in modelo.J_tipos_de_floresta:
    nome = nome_tipos[j]
    valor = modelo.x_variaveis[j].value
    print(f"Área manejada de {nome}: {valor:.2f} ha")

```